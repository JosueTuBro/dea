System.out.println("PRIMOS");
// 1) LISTA EN ARREGLO
        Lista A = new Lista(50);

        //INSERTAR
        A.insertarPrim(5);
        A.insertarUlt(9);
        A.insertarIesimo(7, 1);
        A.insertarLugarAsc(6);
        A.insertarLugarDesc(10);

        System.out.println(A);

        // ----- ELIMINAR (5) -----
        A.eliminarPrim();             
        A.eliminarUlt();
        A.eliminarIesimo(1);
        A.eliminarPrimOcurrencia(5);
        A.eliminarTodo(7);

        System.out.println(A);

        // 2) LISTA DOBLEMENTE ENCADENADA
        ListaDoble D = new ListaDoble();

        //INSERTAR
        D.insertarPrim(5);
        D.insertarUlt(9);
        D.insertarIesimo(7, 1);
        D.insertarLugarAsc(6);
        D.insertarLugarDes(10);
        System.out.println(D);

        //ELIMINAR
        D.eliminarPrim();
        D.eliminarUlt();
        D.eliminarIesimo(1);
        D.eliminarTodo(5);
        D.eliminarTodo(7);
        System.out.println(D);

    }

public class Nodo {
    public Nodo ant, prox;
    public int elem;
    
    public Nodo(int elem, Nodo prox, Nodo ant) { 
        this.elem = elem; 
        this.prox = prox; 
        this.ant = ant; 
    }
}
    
 
public class Lista {
    private int[] elem;
    private int cantElem;
    private int max;

    public Lista(int max) {
        this.max = max;
        this.cantElem = 0;
        this.elem = new int[max];
    }
    
    // toString() iterativo
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        for (int i = 0; i < cantElem; i++) {
            sb.append(elem[i]);
            if (i < cantElem - 1) sb.append(",");
        }
        sb.append("]");
        return sb.toString();
    }
    
    
    
    
    //MÉTODOS INSERTAR 
    public void insertarIesimo(int x, int i) {
        if (cantElem == max) return;
        if (i < 0) i = 0;
        if (i > cantElem) i = cantElem;
        for (int k = cantElem - 1; k >= i; k--) {
            elem[k + 1] = elem[k];
        }
        elem[i] = x;
        cantElem++;
    }

    public void insertarPrim(int x) {
        insertarIesimo(x, 0);
    }

    public void insertarUlt(int x) {
        insertarIesimo(x, cantElem);
    }

    public void insertarLugarAsc(int x) {
        if (cantElem == 0 || x <= elem[0]) { insertarIesimo(x, 0); return; }
        int i;
        for (i = 0; i < cantElem - 1; i++) {
            if (x <= elem[i + 1]) break;
        }
        insertarIesimo(x, i + 1);
    }

    public void insertarLugarDesc(int x) {
        if (cantElem == 0 || x >= elem[0]) { insertarIesimo(x, 0); return; }
        int i;
        for (i = 0; i < cantElem - 1; i++) {
            if (x >= elem[i + 1]) break;
        }
        insertarIesimo(x, i + 1);
    }

    public void concatenar(Lista L2) {
        for (int i = 0; i < L2.cantElem; i++) {
            insertarUlt(L2.elem[i]);
        }
    }

    public void intercalar(Lista L2, Lista L3) {
        int i = 0, j = 0;
        while (i < L2.cantElem || j < L3.cantElem) {
            if (i < L2.cantElem) insertarUlt(L2.elem[i++]);
            if (j < L3.cantElem) insertarUlt(L3.elem[j++]);
        }
    }
    
    
    
    
    //MÉTODOS ELIMINAR
    public void eliminarIesimo(int i) {
        if (i < 0 || i >= cantElem) return;
        for (int k = i; k < cantElem - 1; k++) {
            elem[k] = elem[k + 1];
        }
        cantElem--;
    }

    public void eliminarPrim() {
        eliminarIesimo(0);
    }

    public void eliminarUlt() {
        if (cantElem > 0) eliminarIesimo(cantElem - 1);
    }


    public void eliminarPrimOcurrencia(int x) {
        int pos = -1;
        for (int i = 0; i < cantElem; i++) {
            if (elem[i] == x) { pos = i; break; }
        }
        if (pos == -1) return;

        for (int i = pos; i < cantElem - 1; i++) {
            elem[i] = elem[i + 1];
        }
        cantElem--;
    }

    // 4) eliminarUltOcurrencia(x)  — sin auxiliares
    public void eliminarUltOcurrencia(int x) {
        int pos = -1;
        for (int i = cantElem - 1; i >= 0; i--) {
            if (elem[i] == x) { pos = i; break; }
        }
        if (pos == -1) return;
        for (int i = pos; i < cantElem - 1; i++) {
            elem[i] = elem[i + 1];
        }
        cantElem--;
    }

    public void eliminarTodo(int x) {
        int k = 0;
        for (int i = 0; i < cantElem; i++) {
            if (elem[i] != x) {
                elem[k++] = elem[i];
            }
        }
        cantElem = k;
    }

    public void limpiar() {
        cantElem = 0;
    }
   
}




public class ListaDoble {
    public Nodo prim, ult;
    public int cantElem;

    public ListaDoble() { 
        prim = ult = null; 
        cantElem = 0; 
    }
    public boolean vacia() { 
        return cantElem == 0; 
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("[");
        for (Nodo p = prim; p != null; p = p.prox) {
            sb.append(p.elem);
            if (p.prox != null) sb.append("-");
        }
        sb.append("]");
        return sb.toString();
    }
    
    
    //INSERTAR
    public void insertarPrim(int x) {
        if (vacia()) {
            prim = ult = new Nodo(x, null, null);
        } else {
            Nodo nuevo = new Nodo(x, prim, null);
            prim.ant = nuevo;
            prim = nuevo;
        }
        cantElem++;
    }

    public void insertarUlt(int x) {
        if (vacia()) {
            prim = ult = new Nodo(x, null, null);
        } else {
            Nodo nuevo = new Nodo(x, null, ult);
            ult.prox = nuevo;
            ult = nuevo;
        }
        cantElem++;
    }

    public void insertarIesimo(int x, int i) {
        if (i <= 0) { insertarPrim(x); return; }
        if (i >= cantElem) { insertarUlt(x); return; }
        Nodo p = prim;
        for (int c = 0; c < i; c++) p = p.prox; // p en pos i
        Nodo nuevo = new Nodo(x, p, p.ant);
        p.ant.prox = nuevo;
        p.ant = nuevo;
        cantElem++;
    }

    public void insertarLugarAsc(int x) {
        if (vacia()) { insertarPrim(x); return; }
        Nodo p = prim;
        while (p != null && p.elem < x) p = p.prox;
        if (p == null) { insertarUlt(x); return; }      // todos < x
        if (p.ant == null) { insertarPrim(x); return; } // va primero
        Nodo nuevo = new Nodo(x, p, p.ant);
        p.ant.prox = nuevo;
        p.ant = nuevo;
        cantElem++;
    }

    public void insertarLugarDes(int x) {
        if (vacia()) { insertarPrim(x); return; }
        Nodo p = prim;
        while (p != null && p.elem > x) p = p.prox;
        if (p == null) { insertarUlt(x); return; }      // todos > x
        if (p.ant == null) { insertarPrim(x); return; } // va primero
        Nodo nuevo = new Nodo(x, p, p.ant);
        p.ant.prox = nuevo;
        p.ant = nuevo;
        cantElem++;
    }

    public void insertarPrim(ListaDoble l2) {
        if (l2 == null || l2.vacia()) return;
        if (vacia()) {
            prim = l2.prim; ult = l2.ult; cantElem = l2.cantElem;
        } else {
            l2.ult.prox = prim;
            prim.ant = l2.ult;
            prim = l2.prim;
            cantElem += l2.cantElem;
        }
    }

    public void insertarUlt(ListaDoble l2) {
        if (l2 == null || l2.vacia()) return;
        if (vacia()) {
            prim = l2.prim; ult = l2.ult; cantElem = l2.cantElem;
        } else {
            ult.prox = l2.prim;
            l2.prim.ant = ult;
            ult = l2.ult;
            cantElem += l2.cantElem;
        }
    }


    //ELIMINAR
    public void eliminarPrim() {
        if (vacia()) return;
        if (prim == ult) { prim = ult = null; }
        else { prim = prim.prox; prim.ant = null; }
        cantElem--;
    }

    public void eliminarUlt() {
        if (vacia()) return;
        if (prim == ult) { prim = ult = null; }
        else { ult = ult.ant; ult.prox = null; }
        cantElem--;
    }

    public void eliminarIesimo(int i) {
        if (i < 0 || i >= cantElem || vacia()) return;
        Nodo p = prim;
        for (int c = 0; c < i; c++) p = p.prox;
        eliminarNodo(p.ant, p);
    }

    // (aux)
    private Nodo eliminarNodo(Nodo ap, Nodo p) {
        if (p == null) return (ap == null) ? prim : ap.prox;
        if (p.ant == null) { eliminarPrim(); return prim; }
        if (p.prox == null) { eliminarUlt(); return null; }
        ap.prox = p.prox;
        p.prox.ant = ap;
        cantElem--;
        return ap.prox;
    }

    public void eliminarTodo(int x) {
        Nodo p = prim;
        while (p != null) {
            if (p.elem == x) {
                p = eliminarNodo(p.ant, p);
            } else {
                p = p.prox;
            }
        }
    }

    public int frecuencia(int x) {
        int f = 0; for (Nodo p = prim; p != null; p = p.prox) if (p.elem == x) f++;
        return f;
    }
    public void eliminarUnicos() {
        Nodo p = prim;
        while (p != null) {
            int x = p.elem; Nodo sig = p.prox;
            if (frecuencia(x) == 1) eliminarNodo(p.ant, p);
            p = sig;
        }
    }

    public void eliminarDup() {
        for (Nodo i = prim; i != null; i = i.prox) {
            Nodo j = i.prox;
            while (j != null) {
                if (j.elem == i.elem) j = eliminarNodo(j.ant, j);
                else j = j.prox;
            }
        }
    }

    public void eliminar(ListaDoble l2) {
        if (l2 == null || l2.vacia() || vacia()) return;
        for (Nodo q = l2.prim; q != null; q = q.prox) eliminarTodo(q.elem);
    }
}
