public class Nodo {
    int valor;
    int frec;
    Nodo izq, der;

    public Nodo(int v) {
        valor = v;
        frec = 1;
        izq = der = null;
    }
}

Arbol A1 = new Arbol();
        int[] v1 = {50, 30, 70, 20, 40, 60, 80, 20, 40, 40};
        for (int x : v1) A1.insertar(x);

        System.out.println(A1);
        System.out.println(A1.contarNodos());
        System.out.println(A1.contarHojas());
        System.out.println(A1.altura());
        System.out.println(A1.sumaValores());
        System.out.println(A1.contiene(40));

        System.out.println(A1.frecuenciaDe(40));
        System.out.println(A1.totalFrecuencia());
        System.out.println(A1.cantidadDistintos());
        System.out.println(A1.maxFrecuencia());
        System.out.println(A1.valorMasFrecuente());

        A1.eliminarPares();
        System.out.println(A1);
        A1.eliminarMenor();
        System.out.println(A1);
        A1.eliminarMayor();
        System.out.println(A1);
        A1.eliminarHojas();
        System.out.println(A1);
        A1.eliminar(30);
        System.out.println(A1);

        ListaArbol L1 = new ListaArbol(10);
        int[] v2 = {12, 23, 34, 45, 56, 67, 78, 89, 90, 11};
        for (int x : v2) L1.insertar(x);

        System.out.println(L1);
        System.out.println(L1.totalElementos());
        System.out.println(L1.totalDistintos());
        System.out.println(L1.cantidadArbolesNoVacios());
        System.out.println(L1.indiceArbolMasGrande());
        System.out.println(L1.contieneEnLista(45));

public class ListaArbol {
    private Arbol[] arr;

    public ListaArbol(int n) {
        arr = new Arbol[n];
        for (int i = 0; i < n; i++) arr[i] = new Arbol();
    }

    // inserta x según su último dígito (o modulo n)
    public void insertar(int x) {
        int pos = Math.abs(x % arr.length);
        arr[pos].insertar(x);
    }

    // 1) total elementos (con frecuencia)
    public int totalElementos() {
        int t = 0;
        for (Arbol a : arr) t += a.totalFrecuencia();
        return t;
    }

    // 2) total distintos
    public int totalDistintos() {
        int t = 0;
        for (Arbol a : arr) t += a.cantidadDistintos();
        return t;
    }

    // 3) cantidad de árboles no vacíos
    public int cantidadArbolesNoVacios() {
        int c = 0;
        for (Arbol a : arr) if (!a.estaVacio()) c++;
        return c;
    }

    // 4) índice del árbol con más nodos
    public int indiceArbolMasGrande() {
        int mejor = 0, max = -1;
        for (int i = 0; i < arr.length; i++) {
            int c = arr[i].contarNodos();
            if (c > max) { max = c; mejor = i; }
        }
        return mejor;
    }

    // 5) ¿x está en la lista?
    public boolean contieneEnLista(int x) {
        int pos = Math.abs(x % arr.length);
        return arr[pos].contiene(x);
    }

    // toString de la lista: "[0:[..]-3:[..]-...]"
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (!arr[i].estaVacio()) {
                sb.append(i).append(":").append(arr[i].toString());
                sb.append("-");
            }
        }
        if (sb.length() > 1) sb.setLength(sb.length() - 1);
        sb.append("]");
        return sb.toString();
    }
}

public class Arbol {
    private Nodo raiz;

    // =========== INSERTAR (con frecuencia) =============
    public void insertar(int x) {
        raiz = insertarRec(raiz, x);
    }

    private Nodo insertarRec(Nodo n, int x) {
        if (n == null) return new Nodo(x);
        if (x < n.valor) n.izq = insertarRec(n.izq, x);
        else if (x > n.valor) n.der = insertarRec(n.der, x);
        else n.frec++; // repetido -> solo aumenta frecuencia
        return n;
    }

    public boolean estaVacio() {
        return raiz == null;
    }

    // =========== toString(): "[a-b-c]" =============
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("[");
        toStringRec(raiz, sb);
        if (sb.length() > 1) sb.setLength(sb.length() - 1); // quitar último "-"
        sb.append("]");
        return sb.toString();
    }

    private void toStringRec(Nodo n, StringBuilder sb) {
        if (n == null) return;
        toStringRec(n.izq, sb);
        sb.append(n.valor);
        if (n.frec > 1) sb.append("(").append(n.frec).append(")");
        sb.append("-");
        toStringRec(n.der, sb);
    }

    // ========== (1) CONSULTAS SOBRE ELEMENTOS (5) =========

    // 1) contiene(x)
    public boolean contiene(int x) {
        return contieneRec(raiz, x);
    }

    private boolean contieneRec(Nodo n, int x) {
        if (n == null) return false;
        if (x == n.valor) return true;
        if (x < n.valor) return contieneRec(n.izq, x);
        return contieneRec(n.der, x);
    }

    // 2) contar nodos (distintos)
    public int contarNodos() {
        return contarNodosRec(raiz);
    }

    private int contarNodosRec(Nodo n) {
        if (n == null) return 0;
        return 1 + contarNodosRec(n.izq) + contarNodosRec(n.der);
    }

    // 3) contar hojas
    public int contarHojas() {
        return contarHojasRec(raiz);
    }

    private int contarHojasRec(Nodo n) {
        if (n == null) return 0;
        if (n.izq == null && n.der == null) return 1;
        return contarHojasRec(n.izq) + contarHojasRec(n.der);
    }

    // 4) altura
    public int altura() {
        return alturaRec(raiz);
    }

    private int alturaRec(Nodo n) {
        if (n == null) return 0;
        int ai = alturaRec(n.izq);
        int ad = alturaRec(n.der);
        return 1 + (ai > ad ? ai : ad);
    }

    // 5) suma de valores (ignorando frecuencia)
    public int sumaValores() {
        return sumaValoresRec(raiz);
    }

    private int sumaValoresRec(Nodo n) {
        if (n == null) return 0;
        return n.valor + sumaValoresRec(n.izq) + sumaValoresRec(n.der);
    }

    // ========== (2) CONSULTAS ELIMINANDO ELEMENTOS (5+) =========

    // A1.eliminar(x) (elimina el nodo completo)
    public void eliminar(int x) {
        raiz = eliminarRec(raiz, x);
    }

    private Nodo eliminarRec(Nodo n, int x) {
        if (n == null) return null;
        if (x < n.valor) n.izq = eliminarRec(n.izq, x);
        else if (x > n.valor) n.der = eliminarRec(n.der, x);
        else {
            if (n.izq == null) return n.der;
            if (n.der == null) return n.izq;
            Nodo min = encontrarMin(n.der);
            n.valor = min.valor;
            n.frec  = min.frec;
            n.der = eliminarRec(n.der, min.valor);
        }
        return n;
    }

    private Nodo encontrarMin(Nodo n) {
        while (n != null && n.izq != null) n = n.izq;
        return n;
    }

    // eliminar hojas
    public void eliminarHojas() {
        raiz = eliminarHojasRec(raiz);
    }

    private Nodo eliminarHojasRec(Nodo n) {
        if (n == null) return null;
        if (n.izq == null && n.der == null) return null;
        n.izq = eliminarHojasRec(n.izq);
        n.der = eliminarHojasRec(n.der);
        return n;
    }

    // eliminar pares
    public void eliminarPares() {
        raiz = eliminarParesRec(raiz);
    }

    private Nodo eliminarParesRec(Nodo n) {
        if (n == null) return null;
        n.izq = eliminarParesRec(n.izq);
        n.der = eliminarParesRec(n.der);
        if (n.valor % 2 == 0) return eliminarRec(n, n.valor);
        return n;
    }

    // eliminar menor
    public void eliminarMenor() {
        if (raiz != null) raiz = eliminarMenorRec(raiz);
    }

    private Nodo eliminarMenorRec(Nodo n) {
        if (n.izq == null) return n.der;
        n.izq = eliminarMenorRec(n.izq);
        return n;
    }

    // eliminar mayor
    public void eliminarMayor() {
        if (raiz != null) raiz = eliminarMayorRec(raiz);
    }

    private Nodo eliminarMayorRec(Nodo n) {
        if (n.der == null) return n.izq;
        n.der = eliminarMayorRec(n.der);
        return n;
    }

    // ========== (3) CONSULTAS DE FRECUENCIA (5) =========

    // 1) frecuencia de un valor
    public int frecuenciaDe(int x) {
        return frecuenciaDeRec(raiz, x);
    }

    private int frecuenciaDeRec(Nodo n, int x) {
        if (n == null) return 0;
        if (x == n.valor) return n.frec;
        if (x < n.valor) return frecuenciaDeRec(n.izq, x);
        return frecuenciaDeRec(n.der, x);
    }

    // 2) total de elementos (sumando frecuencias)
    public int totalFrecuencia() {
        return totalFrecuenciaRec(raiz);
    }

    private int totalFrecuenciaRec(Nodo n) {
        if (n == null) return 0;
        return n.frec + totalFrecuenciaRec(n.izq) + totalFrecuenciaRec(n.der);
    }

    // 3) cantidad de valores distintos
    public int cantidadDistintos() {
        return contarNodos();
    }

    // 4) máxima frecuencia
    public int maxFrecuencia() {
        return maxFrecuenciaRec(raiz);
    }

    private int maxFrecuenciaRec(Nodo n) {
        if (n == null) return 0;
        int iz = maxFrecuenciaRec(n.izq);
        int de = maxFrecuenciaRec(n.der);
        int mayorHijos = (iz > de) ? iz : de;
        return (n.frec > mayorHijos) ? n.frec : mayorHijos;
    }

    // 5) valor más frecuente
    public int valorMasFrecuente() {
        Nodo mejor = valorMasFrecuenteRec(raiz);
        return (mejor == null) ? 0 : mejor.valor;
    }

    private Nodo valorMasFrecuenteRec(Nodo n) {
        if (n == null) return null;
        Nodo iz = valorMasFrecuenteRec(n.izq);
        Nodo de = valorMasFrecuenteRec(n.der);
        Nodo mejor = n;
        if (iz != null && iz.frec > mejor.frec) mejor = iz;
        if (de != null && de.frec > mejor.frec) mejor = de;
        return mejor;
    }
}
